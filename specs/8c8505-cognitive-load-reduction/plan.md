---
runId: 8c8505
feature: cognitive-load-reduction
created: 2025-11-10
status: ready
---

# Feature: Three-Skill Split for Cognitive Load Reduction - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/8c8505-cognitive-load-reduction/spec.md
> **Created:** 2025-11-10

## Execution Summary

- **Total Tasks**: 4
- **Total Phases**: 4
- **Sequential Time**: 19h
- **Parallel Time**: 19h
- **Time Savings**: 0h (0%)

**Parallel Opportunities:**

None - all tasks have sequential dependencies.

**Reason:** Task 1 creates foundation skill that Tasks 2 and 3 depend on. Task 2 establishes refactoring pattern for Task 3. Task 4 documents completed implementation.

---

## Phase 1: Create Verification Skill (Foundation)

**Strategy**: sequential
**Reason**: Foundation skill - must be rock-solid before Tasks 2 and 3 depend on it.

### Task 1.1: Create phase-task-verification skill

**Files**:
- skills/phase-task-verification/SKILL.md

**Complexity**: M (4h)

**Dependencies**: None (foundation)

**Description**:
Create shared branch creation and verification logic that will be used by both sequential and parallel task skills. This skill handles git operations (add, branch create, HEAD verification) and supports two modes: sequential (stay on branch) and parallel (detach HEAD).

**Implementation Steps**:

1. Create skill directory and SKILL.md file
2. Write skill metadata (name, description, "When to Use")
3. Implement verification process:
   - Accept parameters: RUN_ID, TASK_ID, TASK_NAME, COMMIT_MESSAGE, MODE
   - Execute `git add .` to stage all changes
   - Execute `gs branch create {branch-name}` with commit message
   - Self-verify HEAD matches expected branch name
   - If MODE=parallel: Execute `git switch --detach` to make branch accessible
4. Add error handling for common failures:
   - Git add fails (no changes, permission issues)
   - Branch create fails (duplicate name, git-spice errors)
   - HEAD verification fails (wrong branch, detached state)
5. Write rationalization table for predictable shortcuts:
   - "Verification is optional" → Required - catches silent failures
   - "Skip detach in parallel mode" → Breaks worktree cleanup
6. Create pressure test scenario for branch creation failures
7. Run pressure test, iterate until bulletproof

**Acceptance Criteria**:
- [ ] Skill handles both MODE: sequential and MODE: parallel correctly
- [ ] Self-verification catches branch creation failures
- [ ] Detach HEAD works in parallel mode (verified: branch accessible in parent repo)
- [ ] Error handling covers all common failure scenarios
- [ ] Pressure test passes: Branch creation failure detection works
- [ ] Skill is ≤50 lines (cognitive load target)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

See patterns.md for skill composition patterns (skills invoke other skills using Skill tool).

**TDD**: Follow `test-driven-development` skill:
1. Write pressure test scenario FIRST (branch creation should fail)
2. Run test → verify FAIL (no skill exists yet)
3. Implement skill with minimal logic
4. Run test → verify PASS
5. Refactor for clarity, run test again

**Quality Gates**:
```bash
# Pressure test the skill
cat tests/pressure/verification-skill-branch-creation-failures.md
# Run test scenario with subagent
# Verify skill catches all failure modes
```

---

## Phase 2: Refactor Sequential Skills

**Strategy**: sequential
**Reason**: Depends on Phase 1 verification skill. Establishes refactoring pattern for Phase 3.

### Task 2.1: Split executing-sequential-phase into orchestrator + task

**Files**:
- skills/executing-sequential-phase/SKILL.md (modify: 750 → 300 lines)
- skills/sequential-phase-task/SKILL.md (create: 100 lines)

**Complexity**: L (6h)

**Dependencies**: Task 1.1 (task skill invokes verification skill)

**Description**:
Refactor the monolithic executing-sequential-phase skill into two focused skills: orchestrator (setup, dispatch, verification, code review) and task execution (phase boundaries, spec reading, implementation, branch creation). This reduces cognitive load for subagents from 750 lines to 100 lines while preserving all functionality.

**Implementation Steps**:

1. **Create sequential-phase-task skill** (100 lines):
   - Write skill metadata and "When to Use" section
   - Add phase boundary section with fixed language (FR3):
     ```
     ===== PHASE BOUNDARIES - CRITICAL =====
     Phase {N}/{total}: {name}
     This phase includes ONLY: Task {current-tasks}

     DO NOT CREATE ANY FILES from later phases.

     Later phases (DO NOT CREATE):
     - Phase {N+1}: {name}
       ❌ NO implementation files
       ❌ NO stub functions (even with TODOs)
       ❌ NO type definitions or interfaces
       ❌ NO test scaffolding or temporary code

     If tempted to create ANY file from later phases, STOP.
     ==========================================
     ```
   - Add rationalization table with 3 observed loopholes:
     | "Stubs aren't implementation" | Stubs are files from later phases. Files = violation. |
     | "Types without logic are OK" | Type files establish contracts. No files from later phases. |
     | "Temporary code for testing" | Temporary becomes permanent. No files from later phases. |
   - Add task execution steps:
     - Read PHASE BOUNDARIES from orchestrator context
     - Read spec from SPEC_PATH
     - Read constitution from docs/constitutions/current/
     - Implement task following boundaries and acceptance criteria
     - Run quality checks (test, lint, build)
     - Invoke `Skill: phase-task-verification` with MODE: sequential
   - Add TodoWrite checklist for sequential steps

2. **Refactor executing-sequential-phase orchestrator** (750 → 300 lines):
   - Remove Step 3 task execution subagent prompt (save removed content for reference)
   - Remove Step 3 item 7c branch creation self-verification
   - Replace with Step 3 dispatch logic:
     ```markdown
     ## Step 3: Dispatch Task Subagent

     For the current task, use the Skill tool to dispatch sequential-phase-task:

     ROLE: Implement Task {task-id}

     PHASE BOUNDARIES:
     {Extract from plan.md and pass to skill}

     TASK DETAILS:
     - Name: {task-name}
     - Files: {explicit-file-paths}
     - Acceptance: {criteria}

     CONTEXT REFERENCES:
     - Spec: specs/{run-id}-{feature-slug}/spec.md
     - Constitution: docs/constitutions/current/
     - Worktree: .worktrees/{run-id}-main
     ```
   - Preserve all other steps: 0 (setup), 1 (context), 2 (ensure on branch), 3.5 (verify branch), 4 (code review), 5 (complete)
   - Ensure orchestrator extracts phase boundaries ONCE and passes to task skill

3. **Test integration**:
   - Create sample spec with 2-task sequential phase
   - Run refactored orchestrator skill
   - Verify task skill receives correct context
   - Verify verification skill creates branch correctly
   - Verify natural stacking works (task-1 → task-2)

4. **Run pressure tests**:
   - phase-boundaries: Verify all 3 loopholes closed (stubs, types, temporary code)
   - missing-branch-detection: Verify verification skill catches failures
   - Iterate if tests reveal new loopholes (REFACTOR phase)

5. **Validate no regressions**:
   - Run validation tests: sequential-phase-single-task, sequential-phase-multiple-tasks
   - Run execution test: simple-sequential-execution
   - Verify all pass

**Acceptance Criteria**:
- [ ] sequential-phase-task skill is ≤100 lines (verified: wc -l)
- [ ] executing-sequential-phase orchestrator is ≤300 lines (verified: wc -l)
- [ ] Phase boundary language includes all 3 explicit loophole counters
- [ ] Rationalization table has entries for observed pressure test failures
- [ ] Context passing works (verified: task receives boundaries, spec path, constitution)
- [ ] Pressure test phase-boundaries PASSES (all 3 loopholes closed)
- [ ] Pressure test missing-branch-detection PASSES
- [ ] Validation tests pass (2/2 sequential tests)
- [ ] Execution test passes (simple-sequential-execution)
- [ ] Natural stacking works (task-1 → task-2 branch dependency)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

See patterns.md for:
- Skills invoke other skills using Skill tool (orchestrator → task → verification)
- RED-GREEN-REFACTOR testing (pressure tests before/after)
- Rationalization tables based on OBSERVED behavior

**TDD**: Follow `test-driven-development` skill:
1. Run pressure test phase-boundaries with CURRENT skill → verify FAIL (should expose loopholes)
2. Implement phase boundary fixes in new task skill
3. Run pressure test again → verify PASS
4. Refactor for clarity (visual emphasis, bullet points)
5. Run pressure test again → verify still PASS

**Quality Gates**:
```bash
# Measure cognitive load reduction
wc -l skills/sequential-phase-task/SKILL.md  # Should be ≤100
wc -l skills/executing-sequential-phase/SKILL.md  # Should be ≤300

# Run pressure tests
# (Pressure test execution via subagent per constitution testing.md)

# Validate no regressions
# (Run validation suite per tests/README.md)
```

---

## Phase 3: Refactor Parallel Skills

**Strategy**: sequential
**Reason**: Depends on Phase 1 verification skill and Phase 2 refactoring pattern.

### Task 3.1: Split executing-parallel-phase into orchestrator + task

**Files**:
- skills/executing-parallel-phase/SKILL.md (modify: 750 → 300 lines)
- skills/parallel-phase-task/SKILL.md (create: 100 lines)

**Complexity**: L (6h)

**Dependencies**: Task 1.1 (task skill invokes verification skill), Task 2.1 (reuse refactoring pattern)

**Description**:
Refactor the monolithic executing-parallel-phase skill following the same pattern as Phase 2. The key difference: parallel-phase-task passes MODE: parallel to verification skill, which triggers HEAD detach. This reduces subagent cognitive load while preserving parallel execution and cross-phase stacking.

**Implementation Steps**:

1. **Create parallel-phase-task skill** (100 lines):
   - Copy structure from sequential-phase-task (Phase 2)
   - Use IDENTICAL phase boundary language and rationalization table
   - Only difference: Change verification invocation to MODE: parallel:
     ```markdown
     Invoke `Skill: phase-task-verification` with:
     - RUN_ID: {run-id}
     - TASK_ID: {phase}-{task}
     - TASK_NAME: {short-name}
     - COMMIT_MESSAGE: "[Task {phase}.{task}] {description}"
     - MODE: parallel
     ```
   - Add note about worktree context: "You are in isolated worktree .worktrees/{task-worktree}"
   - All other steps identical to sequential-phase-task

2. **Refactor executing-parallel-phase orchestrator** (750 → 300 lines):
   - Remove Step 6 task execution subagent prompt (save removed content for reference)
   - Remove Step 6 item 9 branch creation self-verification
   - Replace with Step 6 dispatch logic:
     ```markdown
     ## Step 6: Dispatch Parallel Task Subagents

     For each task, use the Skill tool to dispatch parallel-phase-task:

     ROLE: Implement Task {task-id}

     PHASE BOUNDARIES:
     {Extract from plan.md and pass to skill}

     TASK DETAILS:
     - Name: {task-name}
     - Files: {explicit-file-paths}
     - Acceptance: {criteria}

     CONTEXT REFERENCES:
     - Spec: specs/{run-id}-{feature-slug}/spec.md
     - Constitution: docs/constitutions/current/
     - Worktree: .worktrees/{run-id}-task-{phase}-{task}
     ```
   - Preserve all other steps: 0-5 (setup, worktree creation), 7 (cleanup), 8 (code review)
   - Ensure orchestrator dispatches N subagents in parallel (existing behavior)

3. **Test integration**:
   - Create sample spec with 3-task parallel phase
   - Run refactored orchestrator skill
   - Verify task skills run in parallel (3 worktrees)
   - Verify verification skill detaches HEAD in each worktree
   - Verify cleanup subagent creates linear stack (3 branches)

4. **Run pressure tests**:
   - parallel-stacking-4-tasks: Verify 4 parallel tasks stack correctly
   - Create NEW parallel phase boundaries test: Verify all 3 loopholes closed
   - Iterate if tests reveal new loopholes (REFACTOR phase)

5. **Validate no regressions**:
   - Run validation tests: parallel-phase-worktree-isolation, cross-phase-stacking
   - Run execution test: mixed-sequential-parallel-phases
   - Verify all pass

**Acceptance Criteria**:
- [ ] parallel-phase-task skill is ≤100 lines (verified: wc -l)
- [ ] executing-parallel-phase orchestrator is ≤300 lines (verified: wc -l)
- [ ] Phase boundary language IDENTICAL to sequential-phase-task
- [ ] Only difference: MODE: parallel passed to verification skill
- [ ] Parallel execution works (verified: 3+ tasks run simultaneously)
- [ ] HEAD detach works (verified: branches accessible in parent repo after cleanup)
- [ ] Pressure test parallel-stacking-4-tasks PASSES
- [ ] NEW pressure test parallel-phase-boundaries PASSES (all 3 loopholes closed)
- [ ] Validation tests pass (2/2 parallel tests)
- [ ] Execution test passes (mixed-sequential-parallel-phases)
- [ ] Cross-phase stacking works (sequential → parallel → sequential)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

See patterns.md for:
- Skills invoke other skills using Skill tool (orchestrator → task → verification)
- RED-GREEN-REFACTOR testing (pressure tests before/after)
- Shared logic (verification skill used by both sequential and parallel)

**TDD**: Follow `test-driven-development` skill:
1. Create NEW pressure test parallel-phase-boundaries FIRST
2. Run test with CURRENT skill → verify FAIL (should expose loopholes)
3. Implement parallel-phase-task with phase boundary fixes
4. Run test → verify PASS
5. Refactor for clarity, run test again

**Quality Gates**:
```bash
# Measure cognitive load reduction
wc -l skills/parallel-phase-task/SKILL.md  # Should be ≤100
wc -l skills/executing-parallel-phase/SKILL.md  # Should be ≤300

# Verify parallel execution
# (Dispatch 3-task parallel phase, verify worktrees and branches)

# Run pressure tests
# (Pressure test execution via subagent per constitution testing.md)

# Validate no regressions
# (Run validation suite per tests/README.md)
```

---

## Phase 4: Integration and Documentation

**Strategy**: sequential
**Reason**: Depends on Phase 2 and 3 completing. Documents final architecture.

### Task 4.1: Update documentation and run full validation suite

**Files**:
- commands/execute.md (modify: add new skill architecture documentation)

**Complexity**: M (3h)

**Dependencies**: Task 2.1, Task 3.1 (documents completed refactor)

**Description**:
Update execute command documentation to reflect new three-skill architecture (orchestrator, task execution, verification). Run complete test suite to validate all functionality works: 6 validation tests, 2 execution tests, 2 pressure tests. Verify the refactor achieved cognitive load reduction goals without regressions.

**Implementation Steps**:

1. **Update execute.md documentation**:
   - Add "Architecture" section explaining three-skill split:
     ```markdown
     ## Architecture

     The execute command uses a three-layer skill architecture:

     **Orchestrator Layer** (executing-sequential-phase, executing-parallel-phase)
     - Setup, dispatch, verification, code review
     - ~300 lines each

     **Task Execution Layer** (sequential-phase-task, parallel-phase-task)
     - Phase boundaries, spec reading, implementation, branch creation
     - ~100 lines each (80% cognitive load reduction)

     **Verification Layer** (phase-task-verification)
     - Shared git operations (add, branch create, HEAD verify, detach)
     - ~50 lines, used by both task types
     ```
   - Update any references to old monolithic skill structure
   - Add note about maintainability: "Orchestrator features can be added without modifying task skills"

2. **Run validation test suite** (6 tests):
   - sequential-phase-single-task
   - sequential-phase-multiple-tasks
   - parallel-phase-worktree-isolation
   - parallel-phase-stacking
   - cross-phase-stacking
   - mixed-sequential-parallel-phases
   - Verify all 6 PASS

3. **Run execution test suite** (2 tests):
   - simple-sequential-execution
   - complex-mixed-execution
   - Verify all 2 PASS

4. **Run pressure test suite** (2 tests):
   - phase-boundaries (sequential + parallel)
   - missing-branch-detection
   - Verify all 2 PASS (all 3 loopholes closed)

5. **Integration test**:
   - Create sample spec with 2 sequential phases + 1 parallel phase
   - Run full execution: /spectacular:execute @specs/sample/plan.md
   - Verify:
     - Natural stacking (sequential tasks)
     - Parallel execution (3+ tasks simultaneously)
     - Cross-phase stacking (sequential → parallel → sequential)
     - Code review works
     - No worktree issues

6. **Measure success metrics**:
   - Line count reduction: 750 → 100 for subagents (86% reduction) ✓
   - Phase boundary violations: 0 (pressure test passes) ✓
   - Code review iterations: <1 per phase (measured in integration test)
   - Test suite: 10/10 passing

**Acceptance Criteria**:
- [ ] execute.md documents three-skill architecture clearly
- [ ] All 6 validation tests PASS (sequential, parallel, cross-phase stacking)
- [ ] All 2 execution tests PASS (simple, complex)
- [ ] All 2 pressure tests PASS (phase boundaries, branch detection)
- [ ] Integration test completes successfully (full execution with mixed phases)
- [ ] Natural stacking works (sequential tasks)
- [ ] Parallel execution works (3+ tasks simultaneously)
- [ ] Cross-phase stacking works (sequential → parallel → sequential)
- [ ] No worktree or branch creation issues
- [ ] Cognitive load reduced: 86% (verified: 750 → 100 lines for subagents)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

See testing.md for:
- Run full test suite before marking feature complete
- Binary verdicts (all tests must PASS, no partial success)
- Evidence requirements (test artifacts, pass/fail logs)

**Quality Gates**:
```bash
# Run full validation suite
cat tests/results/{timestamp}/summary.md  # Should show 10/10 PASS

# Measure cognitive load reduction
echo "Before: 750 lines"
wc -l skills/sequential-phase-task/SKILL.md  # Should be ~100
wc -l skills/parallel-phase-task/SKILL.md    # Should be ~100
echo "Reduction: 86%"

# Integration test
# /spectacular:execute @specs/sample/plan.md
# Verify all phases complete, branches stack correctly
```

---

## Notes

**Constitution references:**
- All tasks must follow @docs/constitutions/current/
- architecture.md: Layer boundaries (orchestrator → task → verification)
- patterns.md: Skills invoke skills, RED-GREEN-REFACTOR, rationalization tables
- testing.md: Pressure tests required, binary verdicts, evidence storage

**TDD workflow:**
- Phase 1: Write pressure test FIRST, implement skill to pass
- Phase 2: Run pressure test with old skill (FAIL), fix in new skill (PASS)
- Phase 3: Create NEW pressure test (FAIL), implement fix (PASS)
- Phase 4: Run ALL tests (10/10 PASS)

**Success metrics:**
- Subagent-facing instructions: 750 → 100 lines (86% reduction)
- Phase boundary violations: 3 observed → 0 (all loopholes closed)
- Code review iterations: 1-3 per phase → <1 per phase target
- Test suite: 5/6 validation → 6/6, 1/2 pressure → 2/2

**No parallel opportunities:**
All tasks have sequential dependencies (foundation → sequential refactor → parallel refactor → documentation). This is expected for refactoring work where later phases build on patterns from earlier phases.
