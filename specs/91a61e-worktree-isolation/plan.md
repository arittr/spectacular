---
runId: 91a61e
feature: worktree-isolation
created: 2025-10-27
status: ready
---

# Feature: Worktree-Based Execution Isolation - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/91a61e-worktree-isolation/spec.md
> **Created:** 2025-10-27

## Execution Summary

- **Total Tasks**: 5
- **Total Phases**: 2
- **Sequential Time**: 26h
- **Parallel Time**: 11h
- **Time Savings**: 15h (58% faster)

**Parallel Opportunities:**

- Phase 2: 4 tasks can run simultaneously (15h saved)
  - All command modifications happen in parallel after skill foundation

**Task Breakdown:**

- M (3-5h): 3 tasks (13h)
- L (5-7h): 2 tasks (13h)

---

## Phase 1: Foundation

**Strategy**: Sequential
**Reason**: Must create skill before commands can reference it

### Task 1-1: Main Worktree Management Skill

**Files**:

- `skills/managing-main-worktrees/SKILL.md`

**Complexity**: M (4h)

**Dependencies**: None (foundation task)

**Description**:

Create the `managing-main-worktrees` skill that handles main worktree lifecycle management. This skill will be used by all Spectacular commands (spec, plan, execute) to ensure consistent worktree creation, verification, and git-spice initialization.

This is the foundation layer - all subsequent command modifications depend on this skill being complete and testable.

**Implementation Steps**:

1. Review test scenarios at `skills/managing-main-worktrees/test-scenarios.md`
   - 8 RED phase scenarios document expected rationalizations
   - Command-specific scenarios for spec, list, cleanup
   - Integration tests for concurrent features
2. Create `skills/managing-main-worktrees/` directory (already exists with test scenarios)
3. Create `SKILL.md` following superpowers skill format:
   - YAML frontmatter with name and description
   - "When to Use" section (before worktree operations)
   - "Announce" instruction
   - "The Process" with sequential steps
   - "Quality Rules" section
   - "Error Handling" section
   - Rationalization table
4. Implement worktree lifecycle logic:
   - Run `git worktree prune` to cleanup stale refs (addresses Scenario 1)
   - Check if `.worktrees/main-{runId}/` exists via `git worktree list`
   - If exists: verify accessible with `pwd` (addresses Scenario 8)
   - If not exists: create with `git worktree add --detach .worktrees/main-{runId} HEAD`
5. Add git-spice initialization check (addresses Scenario 3):
   - After creation/entry: run `gs ls 2>/dev/null` to test
   - If not initialized: run `gs repo init --continue-on-conflict`
   - Document that git-spice metadata is shared (stored in .git/)
6. Add rationalization table based on test scenarios:
   - "Worktree already exists, skip prune" → Always prune (cleanup stale refs)
   - "Skip git-spice check, probably initialized" → Always verify (worktree may be orphaned)
   - "No need to verify with pwd" → Always confirm (catch inaccessible worktrees)
   - Reference specific scenarios from test-scenarios.md
7. Add error handling patterns:
   - Worktree creation fails (permission error, disk full)
   - Worktree exists but inaccessible (corrupted, locked)
   - Git-spice initialization fails (conflict, not installed)
8. Include TodoWrite instruction for sequential checklist
9. After skill creation: run RED-GREEN-REFACTOR testing
   - Use `testing-skills-with-subagents` with scenarios from test-scenarios.md
   - Document actual rationalizations observed (verbatim quotes)
   - Update rationalization table if new patterns emerge
   - **Document RED phase results in test-scenarios.md**:
     - Add "## RED Phase Results (Executed: {date})" section
     - For each scenario: document what agent did, agent quotes, key insights
     - Follow format from `skills/decomposing-tasks/test-scenarios.md` lines 285-415
     - This creates permanent record for future skill maintenance

**Acceptance Criteria**:

- [ ] Test scenarios file exists at `skills/managing-main-worktrees/test-scenarios.md`
- [ ] Skill file exists at `skills/managing-main-worktrees/SKILL.md`
- [ ] Follows superpowers skill format (frontmatter, sections, rationalization table)
- [ ] Includes `git worktree prune` as mandatory first step (Scenario 1)
- [ ] Creates worktrees with `--detach` flag (explained in comments)
- [ ] Verifies git-spice initialization after creation/entry (Scenario 3)
- [ ] Verifies working directory with `pwd` after cd (Scenario 8)
- [ ] Has rationalization table with patterns from test scenarios
- [ ] Includes error handling for common failure modes
- [ ] TodoWrite instruction for checklist tracking
- [ ] Tested with `testing-skills-with-subagents` using test-scenarios.md
- [ ] RED-GREEN-REFACTOR cycle completed and documented

**Mandatory Patterns**:

> **Constitution**: Follow @docs/constitutions/current/patterns.md for skill creation

**Use superpowers metaskills**:

- Use `writing-skills` metaskill to create this skill
- Follow RED-GREEN-REFACTOR approach
- Include rationalization table based on observed behavior (not hypothetical)

**Quality Gates**:

```bash
# Validate skill format
cat skills/managing-main-worktrees/SKILL.md | grep -q "^---" # Has frontmatter
cat skills/managing-main-worktrees/SKILL.md | grep -q "## When to Use"
cat skills/managing-main-worktrees/SKILL.md | grep -q "## Rationalization Table"

# Test skill is readable by Claude Code
# (manual test: invoke skill via Skill tool)
```

---

## Phase 2: Command Integration

**Strategy**: Parallel
**Reason**: All tasks depend only on Phase 1 skill, no dependencies between these tasks

All 4 tasks can be implemented simultaneously by different subagents working in isolated worktrees.

### Task 2-1: Spec Command Worktree Integration

**Files**:

- `commands/spec.md`

**Complexity**: L (6h)

**Dependencies**: Task 1-1 (uses managing-main-worktrees skill)

**Description**:

Modify the spec command to handle uncommitted changes and create main worktrees. This is the most complex command modification because it adds a new Step 0.5 with 4 user options and nested failure handling.

The spec command is the entry point for all Spectacular features, so this change ensures isolation from the very beginning of the workflow.

**Implementation Steps**:

1. Read existing `commands/spec.md` to understand current structure
   - **Preserve existing YAML frontmatter** (description field required per architecture.md)
   - Verify frontmatter remains at top of file after modifications
2. Add new Step 0.5 after RUN_ID generation (Step 0):
   - **Check uncommitted changes**: `git status --porcelain`
   - If output is non-empty (dirty state), present AskUserQuestion
3. Implement 4 option UI flow:
   - **Option 1: Commit and proceed**
     - Run `git commit -m "WIP: Spectacular spec creation"`
     - If fails (pre-commit hook): show error with hook output, offer retry or abort
     - On success: worktree will include these changes
   - **Option 2: Stash and proceed**
     - Run `git stash push -m "Spectacular: {feature-slug}"`
     - If fails: show error, offer "proceed anyway" or abort
     - On success: output stash reference (e.g., "Stashed as stash@{0}")
   - **Option 3: Proceed anyway**
     - Create worktree from current HEAD
     - Uncommitted changes stay in main repo only (not in worktree)
   - **Option 4: Abort**
     - Exit cleanly with message about handling changes manually
4. Add recovery instructions for each failure path:
   - Commit failure: "Fix pre-commit hook or commit manually, then re-run"
   - Stash failure: "Stash manually with `git stash` or commit changes"
5. After uncommitted changes handling, add worktree setup:
   - Invoke `managing-main-worktrees` skill
   - Pass RUN_ID to create `.worktrees/main-{runId}/`
   - cd into worktree: `cd .worktrees/main-{runId}/`
6. Update remaining steps to work from main worktree:
   - Step 1-3 (brainstorming): already location-agnostic
   - Step 2 (spec generation): writes to `specs/{runId}-{feature}/spec.md` (relative path, works from worktree)
   - Step 4 (report): output absolute path `.worktrees/main-{runId}/specs/...`
7. Test error paths:
   - Dirty repo → user selects option → success
   - Dirty repo → user selects commit → pre-commit fails → retry/abort flow
   - Dirty repo → user selects stash → stash fails → fallback flow
   - Clean repo → no prompt, proceed to worktree creation

**Acceptance Criteria**:

- [ ] Existing YAML frontmatter preserved (description field intact)
- [ ] Step 0.5 added after RUN_ID generation
- [ ] Checks for uncommitted changes with `git status --porcelain`
- [ ] If dirty: presents 4 options via AskUserQuestion
- [ ] Each option has clear consequence explanation (what happens to uncommitted changes)
- [ ] Commit option uses message "WIP: Spectacular spec creation"
- [ ] Stash option uses `git stash push -m "Spectacular: {feature-slug}"` and outputs stash reference
- [ ] Commit failure shows hook output and offers retry/abort
- [ ] Stash failure offers "proceed anyway" or abort
- [ ] All failure paths include recovery instructions
- [ ] Uses `managing-main-worktrees` skill to create/verify worktree
- [ ] Changes directory to worktree after creation
- [ ] Reports absolute path in completion message
- [ ] Spec file created inside worktree (not main repo)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Follow patterns.md for command structure
- Use AskUserQuestion for user choices (don't hardcode decisions)
- Include error recovery instructions (verification-before-completion pattern)

**Quality Gates**:

```bash
# Validate command structure
cat commands/spec.md | grep -q "Step 0.5.*Uncommitted Changes"
cat commands/spec.md | grep -q "managing-main-worktrees"
cat commands/spec.md | grep -q "AskUserQuestion"

# Manual test
# (Run /spectacular:spec with dirty repo, verify 4 options appear)
```

---

### Task 2-2: Plan & Execute Commands Worktree Integration

**Files**:

- `commands/plan.md`
- `commands/execute.md`

**Complexity**: L (7h)

**Dependencies**: Task 1-1 (uses managing-main-worktrees skill)

**Description**:

Modify plan and execute commands to work with main worktrees. These are bundled together because they follow a similar pattern (extract runId → setup worktree → continue) and are less complex than spec.md.

The execute command also adds dependency detection logic (FR11), which is the most complex part of this task.

**Implementation Steps**:

1. **Modify plan.md**:
   - Read existing `commands/plan.md`
   - **Preserve existing YAML frontmatter** (description field required per architecture.md)
   - Add new Step 0 (Main Worktree Setup)
   - Extract runId from spec path: `@specs/{runId}-{feature}/spec.md`
     - Use regex: `specs/([^-]+)-` to capture runId
     - If path doesn't match: error with expected format
   - Invoke `managing-main-worktrees` skill with extracted runId
   - cd into `.worktrees/main-{runId}/`
   - Update Step N+1 (report): output absolute path
   - Verify plan written to worktree, not main repo

2. **Modify execute.md** (more complex):
   - Read existing `commands/execute.md`
   - **Preserve existing YAML frontmatter** (description field required per architecture.md)
   - Update Step 0a: Extract RUN_ID from plan path (same regex as plan.md)
   - Update Step 0.5: Add main worktree setup
     - Invoke `managing-main-worktrees` skill
     - cd into `.worktrees/main-{runId}/`
   - Add new Step 0.6: Dependency Installation
     - Implement 4-tier detection (FR11):
       1. Check CLAUDE.md for install section (grep for "install", "setup", "dependencies")
       2. If not found: check constitution `@docs/constitutions/current/tech-stack.md`
       3. If not specified: detect from lock files
          - Check in order: pnpm-lock.yaml, package-lock.json, yarn.lock, bun.lockb, Cargo.lock, requirements.txt, Gemfile
          - Map to commands: pnpm install, npm install, yarn install, bun install, cargo build, pip install -r requirements.txt, bundle install
       4. If no lock files: skip install (log info message, not error)
     - Run detected install command in worktree
     - If install fails: fail entire execution with error message
     - Log what was detected and why
   - Update subagent prompts:
     - Sequential task prompts: add `WORKING_DIR: .worktrees/main-{runId}/`
     - Parallel setup subagent: works in main worktree, creates child worktrees
     - Continue using `using-git-worktrees` skill for child worktrees

3. **Test dependency detection**:
   - CLAUDE.md specifies install → uses that
   - No CLAUDE.md, constitution specifies → uses that
   - No docs, has pnpm-lock.yaml → runs `pnpm install`
   - No docs, has Cargo.lock → runs `cargo build`
   - No docs, no lock files → skips with info message
   - Install fails → execution stops with error

**Acceptance Criteria**:

- [ ] plan.md existing YAML frontmatter preserved (description field intact)
- [ ] execute.md existing YAML frontmatter preserved (description field intact)
- [ ] plan.md has new Step 0 for worktree setup
- [ ] plan.md extracts runId from spec path using regex `specs/([^-]+)-`
- [ ] plan.md uses `managing-main-worktrees` skill
- [ ] plan.md changes to worktree directory
- [ ] plan.md reports absolute path in completion message
- [ ] execute.md Step 0a extracts RUN_ID from plan path
- [ ] execute.md Step 0.5 uses `managing-main-worktrees` skill
- [ ] execute.md Step 0.6 detects install procedure (4-tier detection)
- [ ] Dependency detection checks CLAUDE.md first
- [ ] If no CLAUDE.md: checks constitution tech-stack.md
- [ ] If not specified: detects from lock files (7 types: Node, Python, Ruby, Rust)
- [ ] If no lock files: skips install with info message (not error)
- [ ] If install fails: fails execution with error message
- [ ] Sequential task prompts include `WORKING_DIR` parameter
- [ ] Parallel setup works in main worktree context
- [ ] Child worktrees created from main worktree (not main repo)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Follow architecture.md for command orchestration
- Use verification-before-completion: prove install worked before continuing
- Reference tech-stack.md for install procedure precedence

**Quality Gates**:

```bash
# Validate command structure
cat commands/plan.md | grep -q "Step 0.*Main Worktree Setup"
cat commands/execute.md | grep -q "Step 0.6.*Install dependencies"
cat commands/execute.md | grep -q "CLAUDE.md"
cat commands/execute.md | grep -q "Cargo.lock"

# Manual test
# (Run /spectacular:plan and /spectacular:execute, verify worktrees used)
```

---

### Task 2-3: List Command

**Files**:

- `commands/list.md`

**Complexity**: M (4h)

**Dependencies**: Task 1-1 (uses git worktree concepts, but doesn't invoke the skill)

**Description**:

Create the list command that shows all active Spectacular features with their status. This command provides visibility into concurrent features and helps users track their work.

This is a read-only command with no mutations, making it safe to implement in parallel with other modifications.

**Implementation Steps**:

1. Create `commands/list.md` with description frontmatter:
   ```yaml
   ---
   description: List all active Spectacular features with status and staleness
   ---
   ```

2. Implement command logic:
   - **Step 1: Cleanup stale refs**
     - Run `git worktree prune` to remove stale worktree entries
   - **Step 2: Detect default branch** (3-tier fallback per FR9):
     1. Try `git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'`
     2. If fails: try `git config init.defaultBranch`
     3. If fails: assume 'main', warn user to verify
   - **Step 3: Find all worktrees**
     - List `.worktrees/main-*` directories
     - For each directory, extract runId and feature slug from name
   - **Step 4: Analyze each worktree**:
     - Check creation time (mtime of directory)
     - Detect if orphaned: worktree exists but no `specs/{runId}-*/spec.md` inside
     - If not orphaned:
       - Detect phase: check for spec.md, plan.md, branches
       - Phase detection: "spec only" | "spec+plan" | "executed (N branches)"
       - Count branches: `git branch | grep "^  {runId}-" | wc -l`
       - Calculate staleness: compare worktree base to default branch
         - cd into worktree
         - Run `git log --oneline {default-branch}..HEAD | wc -l`
         - If behind: show ⚠️ with commit count
   - **Step 5: Format output**:
     - Sort by creation time (newest first)
     - For normal worktrees: `{runId}: {feature} ({age}) [{phase}] {staleness}`
     - For orphaned: `{runId}: (orphaned) ({age}) - run /spectacular:cleanup {runId}`
     - Handle empty list: "No active Spectacular features"

3. Add example output to documentation:
   ```
   91a61e: worktree-isolation (2h ago) [spec+plan]
   7f3c2a: auth-system (1d ago) [executed: 5 branches] ⚠️  12 commits behind main
   a1b2c3: (orphaned) (3h ago) - run /spectacular:cleanup a1b2c3
   ```

4. Document staleness refresh workflow:
   - User can cd into worktree
   - Use git-spice/graphite to merge default branch
   - Example: `gs stack restack` or `gt stack sync`

**Acceptance Criteria**:

- [ ] Command file exists at `commands/list.md`
- [ ] Has description frontmatter
- [ ] Runs `git worktree prune` first (cleanup stale refs)
- [ ] Detects default branch with 3-tier fallback
- [ ] If default branch detection fails completely: warns user
- [ ] Lists all `.worktrees/main-*` directories
- [ ] Extracts runId and feature slug from directory names
- [ ] Detects orphaned worktrees (no spec.md inside)
- [ ] For orphaned: suggests `/spectacular:cleanup {runId}`
- [ ] For normal worktrees: detects phase (spec only | spec+plan | executed with N branches)
- [ ] Calculates staleness against detected default branch
- [ ] Shows ⚠️ warning if worktree behind default branch
- [ ] Formats age in human-readable units (2h ago, 1d ago)
- [ ] Sorts by creation time (newest first)
- [ ] Handles empty list gracefully (no active features message)
- [ ] Documents staleness refresh workflow (use git-spice/graphite)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Follow patterns.md for command structure
- Use verification-before-completion: prove git commands succeed
- Reference using-git-spice skill for staleness refresh guidance

**Quality Gates**:

```bash
# Validate command structure
cat commands/list.md | grep -q "git worktree prune"
cat commands/list.md | grep -q "symbolic-ref"
cat commands/list.md | grep -q "init.defaultBranch"

# Manual test
# (Create test worktrees, run /spectacular:list, verify output)
```

---

### Task 2-4: Cleanup Command

**Files**:

- `commands/cleanup.md`

**Complexity**: M (5h)

**Dependencies**: Task 1-1 (uses git worktree concepts, but doesn't invoke the skill)

**Description**:

Create the cleanup command that safely removes main worktrees after work is complete. This command is critical for managing disk space and cleaning up completed features.

Includes safety checks (uncommitted changes, unpushed branches) and user confirmation before deletion.

**Implementation Steps**:

1. Create `commands/cleanup.md` with description frontmatter:
   ```yaml
   ---
   description: Remove main worktree for a completed feature with safety checks
   ---
   ```

2. Implement command logic:
   - **Step 1: Parse runId argument**
     - Command format: `/spectacular:cleanup {runId}`
     - Validate runId is provided
   - **Step 2: Verify worktree exists**
     - Run `git worktree list | grep ".worktrees/main-{runId}"`
     - If not found: error "Worktree for runId {runId} not found"
   - **Step 3: Check if orphaned**
     - Check for `specs/{runId}-*/spec.md` inside worktree
     - If missing: mark as orphaned (skip safety checks)
   - **Step 4: Safety checks** (if not orphaned):
     - cd into `.worktrees/main-{runId}/`
     - Check uncommitted changes: `git status --porcelain`
     - List all branches: `git branch | grep "^  {runId}-"`
     - For each branch:
       - Check if upstream exists: `git rev-parse @{u} 2>/dev/null`
       - If upstream exists: check unpushed commits `git log @{u}.. --oneline`
       - If no upstream: mark as "never pushed"
   - **Step 5: Build summary**:
     - Worktree to delete: `.worktrees/main-{runId}/`
     - Uncommitted changes: N files (or "none")
     - Unpushed branches: list with status
     - Branches remain accessible: explain all {runId}-* branches persist
   - **Step 6: Confirm with user**:
     - Use AskUserQuestion with confirm/abort options
     - Show clear consequences (what's deleted, what remains)
   - **Step 7: Execute deletion** (if confirmed):
     - Try `git worktree remove .worktrees/main-{runId}`
     - If fails (orphaned or locked): fallback to `rm -rf .worktrees/main-{runId}`
     - After manual removal: run `git worktree prune`
   - **Step 8: Report status**:
     - Success message: "Cleaned up worktree for {runId}"
     - How to view branches: `git branch | grep '{runId}-'`
     - Note: branches still accessible in main repo

3. Add safety features:
   - Never delete without user confirmation
   - Warn about uncommitted changes (show file count)
   - Warn about unpushed branches (show which branches, commit counts)
   - Graceful handling of orphaned worktrees
   - Fallback removal for corrupted worktrees

4. Reference superpowers patterns:
   - `finishing-a-development-branch` - for branch status patterns
   - `verification-before-completion` - for checking branch push status

**Acceptance Criteria**:

- [ ] Command file exists at `commands/cleanup.md`
- [ ] Has description frontmatter
- [ ] Accepts runId as argument
- [ ] Verifies worktree exists via `git worktree list`
- [ ] Detects orphaned worktrees (no spec.md inside)
- [ ] If not orphaned: checks uncommitted changes with `git status --porcelain`
- [ ] Lists all {runId}-* branches
- [ ] For each branch: checks upstream exists before `git log @{u}..`
- [ ] For branches without upstream: marks as "never pushed"
- [ ] Builds summary showing: worktree to delete, uncommitted changes, unpushed branches
- [ ] Uses AskUserQuestion for confirmation with clear consequences
- [ ] Only deletes after user confirmation
- [ ] Tries `git worktree remove` first
- [ ] Falls back to `rm -rf` + `git worktree prune` for orphaned worktrees
- [ ] Reports cleanup status with command to view remaining branches
- [ ] Branches remain accessible in main repo after cleanup
- [ ] Works for spec-only worktrees (never executed)
- [ ] Works for fully executed worktrees (with branches)
- [ ] References finishing-a-development-branch skill for branch status patterns
- [ ] References verification-before-completion skill for push status checks

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Follow patterns.md for command structure
- Use AskUserQuestion for destructive operations (never delete without confirmation)
- Use verification-before-completion: prove branch push status before warning
- Reference finishing-a-development-branch for branch management patterns

**Quality Gates**:

```bash
# Validate command structure
cat commands/cleanup.md | grep -q "git worktree list"
cat commands/cleanup.md | grep -q "git status --porcelain"
cat commands/cleanup.md | grep -q "git rev-parse @{u}"
cat commands/cleanup.md | grep -q "AskUserQuestion"

# Manual test
# (Create test worktree with uncommitted changes, run cleanup, verify warnings)
```

---

## Version Management

**Breaking Change**: This feature requires major version bump to v2.0.0

After implementation is complete and all tests pass:

```bash
# Bump version to v2.0.0
pnpm version major

# This will:
# - Update package.json to 2.0.0
# - Sync to .claude-plugin/plugin.json
# - Create git commit "chore: bump version to 2.0.0"
# - Create git tag v2.0.0

# Then push
git push && git push --tags
```

**Reason for major version**: NFR1 specifies NO backward compatibility with old specs/plans in main repo. All Spectacular work MUST happen in worktrees going forward.

---

## Testing Strategy

After implementation, verify the entire workflow:

### End-to-End Test

```bash
# 1. Create spec (in worktree)
/spectacular:spec "test feature for worktree isolation"
# Verify: spec created in .worktrees/main-{runId}/specs/

# 2. Create plan (in same worktree)
/spectacular:plan @specs/{runId}-test-feature/spec.md
# Verify: plan created in same worktree

# 3. Check uncommitted changes handling
# Make changes in main repo, run spec again
# Verify: 4 options presented

# 4. List active features
/spectacular:list
# Verify: shows test feature with correct phase

# 5. Execute plan (if tasks exist)
/spectacular:execute @specs/{runId}-test-feature/plan.md
# Verify: execution happens in worktree, main repo untouched

# 6. Verify main repo clean
git status
# Should show: no Spectacular files, no branches

# 7. Verify worktree has branches
cd .worktrees/main-{runId}/
git branch
# Should show: {runId}-task-* branches

# 8. Test concurrent features
# Back in main repo, create second feature
/spectacular:spec "another feature"
# Verify: second worktree created without interference

# 9. Cleanup first feature
/spectacular:cleanup {first-runId}
# Verify: worktree removed, branches remain accessible
```

### Integration Tests

- [ ] Spec command creates worktree and generates spec inside
- [ ] Plan command reuses existing worktree
- [ ] Execute command works entirely in worktree
- [ ] List command shows multiple concurrent features
- [ ] Cleanup command removes worktree safely
- [ ] Main repo never contaminated during workflow
- [ ] Branches accessible from main repo after cleanup

### Skill Tests

Use `testing-skills-with-subagents` to test the new skill with comprehensive test scenarios.

**Test scenarios location**: `skills/managing-main-worktrees/test-scenarios.md`

**RED-GREEN-REFACTOR approach**:

1. **RED Phase**: Run 8 baseline scenarios WITHOUT the skill
   - Document agent rationalizations when skipping safety checks
   - Expected violations: prune skip, git-spice skip, pwd verification skip, etc.

2. **GREEN Phase**: Run same scenarios WITH the skill
   - Verify skill enforces all safety checks
   - Document any new rationalizations

3. **REFACTOR Phase**: Close loopholes
   - Update rationalization table with observed patterns
   - Re-test until bulletproof

**Key scenarios to test**:
- Scenario 1: Worktree prune skip pressure
- Scenario 2: Uncommitted changes detection skip
- Scenario 3: Git-spice initialization skip
- Scenario 4: Cleanup safety checks skip
- Scenario 5: Orphaned worktree fallback skip
- Scenario 6: Path resolution validation skip
- Scenario 7: Dependency detection shortcut
- Scenario 8: Working directory verification skip

**Plus command-specific and integration tests** (E2E-1, E2E-2, SC-1, LC-1, LC-2, CC-1, CC-2)

See `skills/managing-main-worktrees/test-scenarios.md` for complete test instructions.

---

## Constitution Compliance

All tasks must follow:

- **Architecture**: @docs/constitutions/current/architecture.md
  - Commands layer: orchestration only
  - Skills layer: reusable process documentation
- **Patterns**: @docs/constitutions/current/patterns.md
  - Use writing-skills metaskill for skill creation
  - Follow RED-GREEN-REFACTOR for validation
  - Include rationalization tables
- **Tech Stack**: @docs/constitutions/current/tech-stack.md
  - Pure markdown (no build process)
  - Git worktree features only
  - No new dependencies
- **Testing**: @docs/constitutions/current/testing.md
  - Use testing-skills-with-subagents for skill validation
  - Manual testing for commands

---

## References

**Specs**:

- Feature spec: specs/91a61e-worktree-isolation/spec.md

**Skills** (to reference):

- `writing-skills` (superpowers) - for creating managing-main-worktrees skill
- `testing-skills-with-subagents` (superpowers) - for validating new skill
- `verification-before-completion` (superpowers) - for safety checks in cleanup
- `finishing-a-development-branch` (superpowers) - for branch status patterns
- `using-git-spice` (spectacular) - for staleness refresh guidance

**External Docs**:

- Git worktree: https://git-scm.com/docs/git-worktree
- Git-spice: https://github.com/abhinav/git-spice
